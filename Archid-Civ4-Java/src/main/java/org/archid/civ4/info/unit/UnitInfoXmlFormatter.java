/**
 * 
 */
package org.archid.civ4.info.unit;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;
import org.archid.civ4.info.AbstractXmlFormatter;
import org.archid.civ4.info.IXmlInfo;
import org.archid.civ4.info.XmlInfoList;
import org.archid.utils.StringUtils;

/**
 * @author Jim
 *
 */
public class UnitInfoXmlFormatter extends AbstractXmlFormatter {
	
	/** Logging facility */
	static Logger log = Logger.getLogger(UnitInfoXmlFormatter.class.getName());

	private static final String GROUP_AIR = "Air";
	private static final String GROUP_EXEC_LABEL = "Executives";
	private static final String GROUP_EXEC_TAG = "CorporationType";
	private static final String GROUP_GP_LABEL = "Great People";
	private static final String GROUP_GP_TAG = "GreatPeopleType";
	private static final String GROUP_BL_TAG = "bBarbarianLeader";
	private static final String GROUP_MISSILE_LABEL = "Missiles";
	private static final String GROUP_MISSILE_TAG1 = "bMechanized";
	private static final String GROUP_MISSILE_TAG2 = "bSuicide";
	private static final String GROUP_MISSIONARY_LABEL = "Missionaries";
	private static final String GROUP_MISSIONARY_TAG = "ReligionType";
	private static final String GROUP_NAVAL_LABEL = "Naval";
	private static final String GROUP_SETTLER_LABEL = "Settlers";
	private static final String GROUP_SETTLER_TAG = "bFound";
	
	
	private static final String TAG_COMBAT = "iCombat";
	private static final String TAG_COMBAT_TYPE = "Combat";
	private static final String TAG_DOMAIN = "Domain";
	private static final String TAG_UNIT_CLASS = "Class";
	private final List<String> groups = new  ArrayList<String>(Arrays.asList(TAG_COMBAT_TYPE, TAG_DOMAIN));
	private final List<String> stores = new  ArrayList<String>(Arrays.asList(TAG_UNIT_CLASS, TAG_COMBAT, GROUP_SETTLER_TAG, GROUP_GP_TAG, GROUP_BL_TAG, GROUP_EXEC_TAG, GROUP_MISSIONARY_TAG, GROUP_MISSILE_TAG1, GROUP_MISSILE_TAG2));
	private final String groupMissingTagValue = "No Combat";
	
	private Map<String, String> combatTypeMappings;
	
	private StringBuilder out;
	private Map<String, StringBuilder> groupXmls;
	
	private int totalInfoCount;
	
	public UnitInfoXmlFormatter() {
		combatTypeMappings = new HashMap<String, String>();
		combatTypeMappings.put("UNITCOMBAT_ARMOR", "UNITCOMBAT_ARMOUR");
		combatTypeMappings.put("UNITCOMBAT_GUN", "UNITCOMBAT_GUNPOWDER");
		combatTypeMappings.put("UNITCOMBAT_SPY", "UNITCOMBAT_ESPIONAGE");
	}

	
	/**
	 * Updates the XML file generated by Jaxb to replace 4 leading spaces with tabs and will also
	 * take the value of the {@code <Type>} tag and append it as a comment to the info start tag.
	 * 
	 * In addition the infos will be grouped by the tag defined in {@link #setSortTag(String)} which will be preceded by a header. Any infos
	 * that do not contain the group tag then it will be grouped using the value specified by {@link #setGroupMissingTagValue(String)}
	 * 
	 * The resulting, formatted xml file will then be written back with the same filename
	 * 
	 */
	@Override
	public void format(String path) {
		XmlInfoList infoList = new XmlInfoList(path);
		infoList.setMissingTagVal(groupMissingTagValue);
		infoList.parse(groups, stores);
		
		// First output the file header
		out = new StringBuilder(infoList.getHeader());
		groupXmls = new TreeMap<String, StringBuilder>();
		// The units are processed by domain first, with air units being first and then naval and finally land
		// There is an immobile domain, but that is treated with the land units
		Map<String, Set<IXmlInfo>> domainMap = infoList.getIndexMap(TAG_DOMAIN);
		// Record the total number of units processed
		totalInfoCount = 0;
		
		/*
		 * Air Units
		 */
		// Output the domain header comment
		StringBuilder groupSB = new StringBuilder(groupHeader.replaceAll("xxxGROUPxxx",	GROUP_AIR));

		Set<IXmlInfo> airUnits = domainMap.get("DOMAIN_AIR");

		// Now loop through the units for each class, in most cases there will only be a single instance, but there
		// will be multiples where there are UUs for the class that need to be sorted
		// The map is maintained in the following keys: Unit Comment / Unit
		Map<String, IXmlInfo> sortedAirInfos = new TreeMap<String, IXmlInfo>();
		for (IXmlInfo info: airUnits) {
			// We will process the missiles later
			if (info.getTagValue(GROUP_MISSILE_TAG2) != null) continue;
			// If the type matches the class then we will use the type only
			String unitType = getCommentText(info.getType());
			String unitClass = getCommentText(info.getTagValue(TAG_UNIT_CLASS));
			if (!unitType.equals(unitClass)) {
				unitType = unitClass + ": " + unitType;
			}
			info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", unitType));
			sortedAirInfos.put(info.getStartTag(), info);
		}
		int groupCount = 0;
		for (IXmlInfo info: sortedAirInfos.values()) {
			groupSB.append(info.getXml());
			groupCount++;
		}
		totalInfoCount += groupCount;
		log.info("Processed " + groupCount + " " + GROUP_AIR + " units");
		groupXmls.put(GROUP_AIR, groupSB);
		
		/*
		 * Naval Units
		 * 
		 * The processing of these is done by the combat type, such as wooden or diesel and then
		 * by the combat strength of the unit. In order to allow for dynamic combat types we need
		 * a mechanism to work out which comes first. This is done by getting the average strength
		 * of all the units in the combat type and sorting by that. 
		 */
		
		// Define the unit combats we are not processing here
		List<String> ignoredCombatTypes = new ArrayList<String>(Arrays.asList("UNITCOMBAT_WORKER"));
		Set<String> infosToProcessAsLand = new HashSet<String>();
		
		// Output the domain header comment
		groupSB = new StringBuilder(newline + newline + groupHeader.replaceAll("xxxGROUPxxx",	getCommentText(GROUP_NAVAL_LABEL)));
		Set<IXmlInfo> navalUnits = domainMap.get("DOMAIN_SEA");

		// First split the units by combat type as we will be commenting those groupings.
		// We also want to exclude workboats as they should be grouped with the workers
		
		/* Map keyed as follows: CombatType -> UnitStrength/UnitClass */ 
		Map<String, Set<String>> navalCombats = new HashMap<String, Set<String>>();
		Map<String, Map<String, IXmlInfo>> unitClassTypes = new HashMap<String, Map<String, IXmlInfo>>();
		Map<String, Integer> combatTotalStrength = new HashMap<String, Integer>();
		Map<String, Integer> combatTotalCount = new HashMap<String, Integer>();
		
		for (IXmlInfo info: navalUnits) {
			String combatType = info.getTagValue(TAG_COMBAT_TYPE);
			if (ignoredCombatTypes.contains(combatType)) {
				infosToProcessAsLand.add(info.getType());
				continue;
			}
			
			// If the type matches the class then we will use the type only for the comment
			String unitType = info.getType();
			String label = getCommentText(unitType);
			String unitClass = info.getTagValue(TAG_UNIT_CLASS);
			String formattedUnitClass = getCommentText(unitClass);
			boolean defaultUnit = label.equals(formattedUnitClass);
			if (!defaultUnit) {
				label = formattedUnitClass + ": " + label;
			}
			info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", label));
			
			// Add the unit to the set of units for the unitclass
			if (!unitClassTypes.containsKey(unitClass)) unitClassTypes.put(unitClass, new TreeMap<String, IXmlInfo>());
			unitClassTypes.get(unitClass).put(label, info);

			// Now start the sorting process, but we only care about the default units
			if (defaultUnit) {
				if (!navalCombats.containsKey(combatType)) navalCombats.put(combatType, new TreeSet<String>());
				Integer strength = Integer.parseInt(info.getTagValue(TAG_COMBAT));
				navalCombats.get(combatType).add(unitClass);
				combatTotalStrength.put(combatType, combatTotalStrength.containsKey(combatType) ? combatTotalStrength.get(combatType) + strength : strength);
				combatTotalCount.put(combatType, combatTotalCount.containsKey(combatType) ? combatTotalCount.get(combatType) + 1 : 1);
			}
		}
		// Now we have done our first pass at the units, now work out the order to output the combat types
		Map<Double, String> averages = new TreeMap<Double, String>();
		for (String combatType: combatTotalCount.keySet()) {
			Integer count = combatTotalCount.get(combatType);
			Integer str = combatTotalStrength.get(combatType);
			averages.put(str * 1.0 / count, combatType);
		}
		// Loop through the combat types, finally outputting the info data
		groupCount = 0;
		for (String combatType: averages.values()) {
			groupSB.append(typeHeader.replaceAll("xxxTYPExxx", getCommentText(combatType)) + newline);
			for (String unitClass: navalCombats.get(combatType)) {
				for (IXmlInfo info: unitClassTypes.get(unitClass).values()) {
					groupSB.append(info.getXml());
					groupCount++;
				}
			}
		}
		totalInfoCount += groupCount;
		log.info("Processed " + groupCount + " " + GROUP_NAVAL_LABEL + " units");
		groupXmls.put(GROUP_NAVAL_LABEL, groupSB);


		/*
		 * Land units
		 * 
		 * These are processed using the combat type index and we filter out the air and sea units
		 */
		
		// We should now have a map keyed on the combat field
		Map<String, Set<IXmlInfo>> combatMap = infoList.getIndexMap(TAG_COMBAT_TYPE);
		
		// We are going to sort the units in each group by combat strength, but also need to take into account UUs
		// In order to do this we maintain 2 maps keyed on the class, one with the strength of the default unit
		//  and the second with the list of units in that class sorted on their comment field which will order
		//  the UUs correctly
		Map<String, Map<String, IXmlInfo>> classUnitLists;
		Map<String, Set<String>> classOrders;
		
		// Now output each group of combat types
		for (String group: combatMap.keySet()) {
			// Deal with the special cases
			if (group.equals(groupMissingTagValue)) {
				Map<String, StringBuilder> noCombatGroups = parseNoUnitCombat(combatMap.get(groupMissingTagValue));
				for (String groupName: noCombatGroups.keySet()) {
					groupXmls.put(groupName, noCombatGroups.get(groupName));
				}
				continue;
			}
			
			// See if we should be using a different value for the group label
			String label = combatTypeMappings.containsKey(group) ? combatTypeMappings.get(group) : group;

			// Reset the group lists
			classUnitLists = new TreeMap<String, Map<String, IXmlInfo>>();
			classOrders = new TreeMap<String, Set<String>>();
			groupSB = new StringBuilder();
			
			Set<IXmlInfo> combatInfos = combatMap.get(group);
			/// We only output the group header if there are any units to process so check that here
			boolean headerPrinted = false;

			for (IXmlInfo info: combatInfos) {
				
				// First check whether this info has been processed previously
				String domain = info.getTagValue(TAG_DOMAIN);
				String unitType = getCommentText(info.getType());
				if (!infosToProcessAsLand.contains(info.getType()) && (domain.equals("DOMAIN_AIR") ||  domain.equals("DOMAIN_SEA"))) continue;
				
				// We have some infos so output the header comment if this is the first info
				if (!headerPrinted) {
					groupSB.append(newline + newline + groupHeader.replaceAll("xxxGROUPxxx",	getCommentText(label)));
					headerPrinted = true;
				}

				// If the type matches the class then we will use the type only and use the combat value to order the unit
				String unitClass = getCommentText(info.getTagValue(TAG_UNIT_CLASS));
				if (unitType.equals(unitClass)) {
					String iCombat = info.getTagValue(TAG_COMBAT);
					String order = iCombat == null ? info.getTagValue(TAG_UNIT_CLASS) : StringUtils.padValue(Integer.parseInt(iCombat), 4, '0');
					if (!classOrders.containsKey(order)) classOrders.put(order, new TreeSet<String>());
					classOrders.get(order).add(unitClass);
				} else {
					unitType = unitClass + ": " + unitType;
				}
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", unitType));
				if (!classUnitLists.containsKey(unitClass)) classUnitLists.put(unitClass, new TreeMap<String, IXmlInfo>());
				classUnitLists.get(unitClass).put(info.getStartTag(), info);
			}
			// Loop through the unit classes in the group outputting them in strength order
			groupCount =0;
			for (Set<String> unitClasses: classOrders.values()) {
				for (String unitClass: unitClasses) {
					for (IXmlInfo info: classUnitLists.get(unitClass).values()) {
						groupSB.append(info.getXml());
						groupCount++;
					}
				}
			}
			totalInfoCount += groupCount;
			// We only process unit types that have not been processed previously so
			//  there will be some combat classes that have no units in this group
			if (groupCount > 0)
				log.info("Processed " + groupCount + " " + getCommentText(label) + " units");
			
			if (headerPrinted)
				groupXmls.put(getCommentText(label), groupSB);
		}
		
		log.info("Wrote " + totalInfoCount + " total units");
		for (StringBuilder sb: groupXmls.values()) {
			out.append(sb.toString());
		}
		
		out.append(infoList.getFooter());

		File xmlFile = new File(path);
		try {
			
			BufferedWriter writer = new BufferedWriter(new FileWriter(xmlFile));
			writer.write(out.toString());
			writer.close();
			
		} catch (IOException e) {
			log.error("Could not access the file", e);
		}
	}

	private Map<String, StringBuilder> parseNoUnitCombat(Set<IXmlInfo> infos) {
		Map<String, StringBuilder> infoBuilders = new TreeMap<String, StringBuilder>();
		Map<String, Set<IXmlInfo>> infoGroups = new TreeMap<String, Set<IXmlInfo>>();
		
		Map<String, String> execTitles = new HashMap<String, String>();
		execTitles.put("UNIT_EXECUTIVE_1", " (Cereal Mills)");
		execTitles.put("UNIT_EXECUTIVE_2", " (Sid's Suchi Co.)");
		execTitles.put("UNIT_EXECUTIVE_3", " (Std Ethanol)");
		execTitles.put("UNIT_EXECUTIVE_4", " (Creative Constructions)");
		execTitles.put("UNIT_EXECUTIVE_5", " (Mining Inc.)");
		execTitles.put("UNIT_EXECUTIVE_6", " (Aluminium Co.)");
		execTitles.put("UNIT_EXECUTIVE_7", " (Civilized Jewelers)");
		
		for(IXmlInfo info: infos) {
			if (info.getTagValue(GROUP_SETTLER_TAG) != null) {
				if (!infoGroups.containsKey(GROUP_SETTLER_LABEL)) infoGroups.put(GROUP_SETTLER_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(GROUP_SETTLER_LABEL).add(info);
			} else if (info.getTagValue(GROUP_BL_TAG) != null) {
				if (!infoGroups.containsKey(GROUP_GP_LABEL)) infoGroups.put(GROUP_GP_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(GROUP_GP_LABEL).add(ensureGPLabel(info));
			} else if (info.getTagValue(GROUP_GP_TAG) != null) {
				if (!infoGroups.containsKey(GROUP_GP_LABEL)) infoGroups.put(GROUP_GP_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(GROUP_GP_LABEL).add(ensureGPLabel(info));
			} else if (info.getTagValue(GROUP_EXEC_TAG) != null) {
				if (!infoGroups.containsKey(GROUP_EXEC_LABEL)) infoGroups.put(GROUP_EXEC_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType()) + execTitles.get(info.getType())));
				infoGroups.get(GROUP_EXEC_LABEL).add(info);
			} else if (info.getTagValue(GROUP_MISSILE_TAG1) != null && info.getTagValue(GROUP_MISSILE_TAG2) != null) {
				if (!infoGroups.containsKey(GROUP_MISSILE_LABEL)) infoGroups.put(GROUP_MISSILE_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(GROUP_MISSILE_LABEL).add(info);
			} else if (info.getTagValue(GROUP_MISSIONARY_TAG) != null) {
				if (!infoGroups.containsKey(GROUP_MISSIONARY_LABEL)) infoGroups.put(GROUP_MISSIONARY_LABEL, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(GROUP_MISSIONARY_LABEL).add(info);
			} else {
				if (!infoGroups.containsKey(groupMissingTagValue)) infoGroups.put(groupMissingTagValue, new TreeSet<IXmlInfo>());
				info.setStartTag(info.getStartTag() + ' ' + typeHeader.replaceAll("xxxTYPExxx", getCommentText(info.getType())));
				infoGroups.get(groupMissingTagValue).add(info);
			}
		}
		
		for (String group: infoGroups.keySet()) {
			StringBuilder sb = new StringBuilder(newline + newline + groupHeader.replaceAll("xxxGROUPxxx",	group));
			for (IXmlInfo info: infoGroups.get(group)) {
				sb.append(info.getXml());
			}
			infoBuilders.put(group, sb);
			log.info("Processed " + infoGroups.get(group).size() + " " + group + " units");
			totalInfoCount += infoGroups.get(group).size();

		}
		return infoBuilders;
	}

	private IXmlInfo ensureGPLabel(IXmlInfo info) {
		String startTag = info.getStartTag();
		if (!startTag.contains("Great")) {
			Pattern pattern = Pattern.compile("(.*<!-- )(.*)");
			Matcher matcher = pattern.matcher(startTag);
			if (matcher.matches()) {
				info.setStartTag(matcher.group(1) + "Great " + matcher.group(2));
			}
			
		}
		return info;
	}


}
